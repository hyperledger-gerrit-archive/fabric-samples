/*
* Copyright Persistent Systems 2018. All Rights Reserved.
* 
* SPDX-License-Identifier: Apache-2.0
*/

package main

/* Imports
 * 1 utility libraries for formatting
 * 2 specific Hyperledger Fabric specific libraries for Smart Contracts
 */
import (
	"fmt"
	"strconv"	
	//"strings"
	"encoding/json"	
	"time"
	"runtime"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/core/chaincode/lib/cid"	
	sc "github.com/hyperledger/fabric/protos/peer"	
)

// define structures to be used
type Item struct{
	TypeOfObject	string `json:"typeOfObject"`
	ItemId   		string `json:"itemId"`
	Name  			string `json:"name"`
	Description		string `json:"description"`
	Category  		string `json:"category"`
	Currency  		string `json:"currency"`
	MinBidPrice 	float32 `json:"minBidPrice"`	
	CreatedOn  		string `json:"createdOn"`
	Status  		string `json:"status"`
	Owner  			string `json:"owner"`
	Creator  		string `json:"creator"`
	AuctionStartTime  	string `json:"auctionStartTime"` //dd-mm-yyyy hh:mm:ss
	AuctionEndTime  	string `json:"auctionEndTime"`	
	CurrHighestBid	float32 `json:"currHighestBid"`
}

/* Init: set typeOfObject  */
func (t *Item) Init() {
	t.TypeOfObject = configObj.TypeOfObject.ItemDoc
}


type ItemList struct{
	Key string
	Record Item
}

type ItemPrivate struct{
	TypeOfObject	string `json:"typeOfObject"`
	ItemId   		string `json:"itemId"`
	ReservePrice	string `json:"reservePrice"`
}
/* Init: set typeOfObject  */
func (t *ItemPrivate) Init() {
	t.TypeOfObject = configObj.TypeOfObject.ItemPrivDoc
}

type ItemWithReservePrice struct{
	Item
	ReservePrice	string `json:"reservePrice"`
}


// need to sort on bidamount hence lets make in int
type Bid struct{
	TypeOfObject 	string `json:"typeOfObject"`
	BidId  			string `json:"bidId"`
	ItemId 			string `json:"itemId"`
	Bidder 			string `json:"bidder"`
	BidAmount 		float32 `json:"bidAmount"`
	Status			string `json:"status"`
}

/* Init: set typeOfObject  */
func (t *Bid) Init() {
	t.TypeOfObject = configObj.TypeOfObject.BidDoc
}

type BidList struct{
	Key		string
	Record	Bid
}

type UserProfile struct{
	TypeOfObject	string 	`json:"typeOfObject"`
	LoginId 	 	string 	`json:"loginId"`
	AvlBalance 		float32 `json:"avlBalance"`
	Currency 		string 	`json:"currency"`
	Remarks 		string 	`json:"remarks"`
	Role			string  `json:"role"`
}
/* Init: set typeOfObject  */
func (t *UserProfile) Init() {
	t.TypeOfObject = configObj.TypeOfObject.UserProfileDoc
}

var RoleSupported = []string{"seller", "buyer"}

/* Different type of documents on couch DB */
type DocType struct{
	ItemDoc			string
	ItemPrivDoc		string
	UserProfileDoc 	string
	BidDoc			string
}

/* Events generated by Auction SC */
type EventType struct{
	CreateItem	string
	PlaceBid 	string
	UpdateBid	string
	AuctionSold		string
	AuctionCanceled string
	UserRegistered string
}

/* State of a Item Object */
type ItemStatus struct{
	Created 	 	string
	Sold 		 	string
	AuctionCanceled string
}

type BidStatus struct{
	Active 		string
	Inactive 	string
}

type QryResType struct{
	Single		string
	Multiple	string
}
type UserRole struct{
	Buyer string
	Seller string 
}

type Config struct{
	TypeOfObject 	DocType
	Event			EventType
	ItemStatus		ItemStatus
	BidStatus		BidStatus
	DateFormat		string
	TxDateFormat	string
	QryResultType	QryResType
	ReservePriceCollName string
	Role 			UserRole
}

func (t *Config) Init() {
	t.TypeOfObject.ItemDoc 			= "ITEM"
	t.TypeOfObject.ItemPrivDoc 		= "ITEM-PRIVATE"
	t.TypeOfObject.UserProfileDoc 	= "USER-PROFILE"
	t.TypeOfObject.BidDoc 			= "BID"

	t.Event.CreateItem  = "create-item"
	t.Event.PlaceBid 	= "place-bid"
	t.Event.UpdateBid	= "update-bid"
	t.Event.AuctionSold = "auction-sold"
	t.Event.AuctionCanceled	= "auction-canceled"
	t.Event.UserRegistered  = "user-registered"

	t.ItemStatus.Created = "CREATED"
	t.ItemStatus.Sold	 = "SOLD"
	t.ItemStatus.AuctionCanceled = "AUCTION-CANCELED"

	t.BidStatus.Active   = "ACTIVE"
	t.BidStatus.Inactive = "INACTIVE"
	
	t.DateFormat 	  	= "02-01-2006 15:04:05"
	t.TxDateFormat		= "2006-01-02T15:04:05Z"

	// CouchDB query result
	t.QryResultType.Single	 =	"SINGLE"
	t.QryResultType.Multiple =	"MULTIPLE"

	t.ReservePriceCollName = "collectionReservePrice"

	t.Role.Buyer  = "buyer"
	t.Role.Seller = "seller"
}

type Response struct{
	ErrCode 	string `json:"errCode"`
	ErrMessage 	string `json:"errMessage"`
}

type AuctionSC struct{

}

/* Global logger object */
var logger = shim.NewLogger("AuctionSC")

/* Global configuration object */
var configObj Config

func (s *AuctionSC) Init(APIstub shim.ChaincodeStubInterface) sc.Response{
	return shim.Success(nil)
}

func (s *AuctionSC) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response{
	function, args := APIstub.GetFunctionAndParameters()
	
		switch function {		
	
			/* Item Functions */
			case "createItem":
				return s.createItem(APIstub, args)
			case "listItems":
				return s.listItems(APIstub, args)
			/*case "listItemsByStatus":
				return s.listItemsByStatus(APIstub, args)
				*/
			case "auction":
				return s.auction(APIstub, args)
				
			// Bid Functions /
			case "placeBid":
				return s.placeBid(APIstub, args)
			/*
			case "listBidsByBuyer":
				return s.listBidsByBuyer(APIstub, args)
			case "listBidsByItem":
				return s.listBidsByItem(APIstub, args)			
				*/
			// User Functions /
			case "registerUser":
				return s.registerUser(APIstub, args)
			/*case "viewUser":
				return s.viewUser(APIstub, args)
			case "addToAvlBalance":
				return s.addToAvlBalance(APIstub, args)
				*/
	
		}
		return shim.Error("Invalid function name passed::" + function)

}

/* Create Item for auction */
func (s *AuctionSC) createItem(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")

	var item Item
	var itemPriv ItemPrivate

	configObj.Init()
	item.Init()
	itemPriv.Init()

	// Check input parameters - all mandatory parameters
	if len(args) != 8 {
		argslen := strconv.Itoa(len(args))
		logger.Info(args)

		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Incorrect #Args. Expecting 8 parameters in given order - Name, Description , Category, Currency, MinBidPrice, Creator, AuctionStartDateTime, AuctionEndDateTime; Got " + argslen)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}


	privateData, errTr := APIstub.GetTransient()
	logger.Info("privateData :: ", privateData)
	
	if errTr!=nil{
		return shim.Error("Error while fetching data from transient field" + errTr.Error())		
	}

	logger.Info( privateData)
	logger.Info( string(privateData["reservePrice"]))

	
	// Fetch the role attribute from user's certificate
	value, found, errC := cid.GetAttributeValue(APIstub,"role")
	if errC!=nil{
		logger.Info("Eror in cid.GetAttributeValue(\"role\") ")
	}
	logger.Info(value, found)

	if value != configObj.Role.Seller{
		respBytes := formResponse(funcName(), "RoleNotAllowed", ":: User does not belong to "+configObj.Role.Seller+" role ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}


	// Add Public data to Item object
	item.Name 			= args[0]
	item.Description  	= args[1]
	item.Category 		= args[2]
	item.Currency 		= args[3]
	
	f, _ := strconv.ParseFloat(args[4], 32)		
	item.MinBidPrice 	= float32(f)
	item.Creator 		= args[5]
	item.AuctionStartTime 	= args[6]
	item.AuctionEndTime 	= args[7]
	
	item.CurrHighestBid = item.MinBidPrice


	// Add current time to creation datetime field	
	timestamp,_ := APIstub.GetTxTimestamp() 
	Timestamp := time.Unix(timestamp.Seconds, int64(timestamp.Nanos)).String()
	logger.Info("Timestamp from GetTxTtimestamp::: ", Timestamp)
	
	unixTimeUTC:=time.Unix(timestamp.Seconds, 0) //gives unix time stamp in utc 
    unitTimeInRFC3339 :=unixTimeUTC.Format(time.RFC3339)

	logger.Info("Timestamp from GetTxTtimestamp::: unitTimeInRFC3339 ", unitTimeInRFC3339)
	
	item.CreatedOn  = unitTimeInRFC3339 //time.Now().Format(configObj.DateFormat)
	item.ItemId	 	= item.TypeOfObject + "-"+ APIstub.GetTxID()
	item.Status 	= configObj.ItemStatus.Created
	item.Owner 		= item.Creator

	// Add Private details to itemPriv
	itemPriv.ItemId 		= item.ItemId
	itemPriv.ReservePrice 	= string(privateData["reservePrice"])
	
	// check if LoginId supplied exists on StateDB
	exists,_ := doesKeyExist(APIstub, item.Creator)
	if !exists{
		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Supplied LoginId does not exist on stateDb")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	logger.Info("Writing public data to stateDB")

	if ok, errWrite := writeToLedger(APIstub, item.ItemId, item); !ok {

		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Item object to StateDB :: " + errWrite.Error() + "\"}"
		return shim.Error(jsonResp)	
	}

	logger.Info(funcName() + ":: Created Item object on stateDB with Id - ", item.ItemId)

	logger.Info("Now writing Private Data to stateDB")

	if ok, errWritePrv := writeToPrivateState(APIstub, configObj.ReservePriceCollName,itemPriv.ItemId, itemPriv); !ok {

		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Item-Private object to StateDB :: " + errWritePrv.Error() + "\"} "
		return shim.Error(jsonResp)		
	}

	logger.Info(funcName() + ":: Created Item object on Private stateDB with Id - ", itemPriv.ItemId)

	// Marshal the object to send to event
	itemAsBytes, err := json.Marshal(item)
	if err!=nil{
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the item object - " + item.ItemId)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	// generate create-item event
	err = APIstub.SetEvent(configObj.Event.CreateItem, itemAsBytes)
	if err != nil {			
		respBytes := formResponse(funcName(), "InvalidEvent", ":: Error while setting "+ configObj.Event.CreateItem+ " event")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	responseAsBytes, err1 := json.Marshal(item)
	if err1!=nil{		
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the trade object")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}	

	// Success response would be the item that was created on Public State
	return shim.Success(responseAsBytes)

}
/* List all the items created so far... */
func (s *AuctionSC) listItems(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")

	configObj.Init()

	// Check input parameters - all mandatory parameters
	if len(args) != 1 {
		argslen := strconv.Itoa(len(args))
		logger.Info(args)

		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Incorrect #Args. Expecting 1 parameter - LoginId; Got " + argslen)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}

	// check if LoginId supplied exists on StateDB
	exists,_ := doesKeyExist(APIstub, args[0])
	if !exists{
		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Supplied LoginId does not exist on stateDb")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	queryString   := fmt.Sprintf("{\"selector\":{\"typeOfObject\":\"%s\"} }", configObj.TypeOfObject.ItemDoc)
	qryResultType := configObj.QryResultType.Multiple
	
	queryResults, err := getQueryResultForQueryString(APIstub, queryString, qryResultType)
	
	if err != nil {		
		respBytes := formResponse(funcName(), "CouchDbQuery", ":: Error fetching item data from CouchDB ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	logger.Info("Fetched results from public state")

	var items []ItemList
	err = json.Unmarshal(queryResults, &items)
	if err!=nil{
		respBytes := formResponse(funcName(), "UnmarshallingErr", "Error while unmarshalling the list of items")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}	
	}

	// As the Record in ItemList is map; it cannot be assigned to a interface; 
	// Hence we need to create another list of items which may include reserve price field
	// Reserve price would be added if supplied login id is the creator of item
	var itemsRP []ItemWithReservePrice

	// These are items w/o reserve price
	for _, item := range items{

		logger.Info("Check whether creator is supplied loginId")
		reservePriceForItem := ""

		//if item.Record.Creator == args[0]{ // TODO: remove teh access control to demo actual use of Private Data
		
			logger.Info("readFromPrivateState ....")
			err, valAsbytes := readFromPrivateState(APIstub,configObj.ReservePriceCollName, item.Record.ItemId)

			if err!=nil{
				respBytes := formResponse(funcName(), "FetchFromPrivateState", "Error while fetching existing private item object")
				if respBytes == nil{
					return shim.Error("Error while marshalling the response object")
				}
				//return shim.Success(respBytes)
			}else{
				// if no error while reading private data then add the private data to list of items
				var itemPriv ItemPrivate
				errUnmarshal := json.Unmarshal(valAsbytes, &itemPriv)
				if errUnmarshal!=nil{			
					respBytes := formResponse(funcName(), "UnmarshallErr", "Error while unmarshaling existing private item object")
					if respBytes == nil{
						return shim.Error("Error while marshalling the response object")
					}
					return shim.Success(respBytes)
				}
				logger.Info("Private data fetched :: ")
				logger.Info(itemPriv)
	
				logger.Info("adding reserve price information for creator of item")
				reservePriceForItem = itemPriv.ReservePrice
	
				logger.Info(item.Record)
			}
			
		//}
		
		itemsRP = append(itemsRP, ItemWithReservePrice{Item: item.Record, ReservePrice: reservePriceForItem})
	}

	logger.Info("list of items with reserve price :: ")
	logger.Info(itemsRP)
	
	//Marshal the results to send response 	
	itemsRPAsBytes, err1 := json.Marshal(itemsRP)
	if err1!=nil{
		respBytes := formResponse(funcName(), "MarshallErr", "Error while marshaling existing item list object")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	

	logger.Info("send the queryresults to the client")
	return shim.Success(itemsRPAsBytes)
}
/*
func (s *AuctionSC) listItemsByStatus(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")
}
*/
func (s *AuctionSC) placeBid(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")

	// Check parameters
	var item Item
	var bid Bid

	configObj.Init()
	item.Init()
	bid.Init()

	// Check input parameters - all mandatory parameters
	if len(args) != 3 {
		argslen := strconv.Itoa(len(args))
		logger.Info(args)

		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Incorrect #Args. Expecting 3 parameters in given order - ItemId, BidAmount, Bidder; Got " + argslen)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}
	// Check if bidder has already placed a bid ; if yes then add supplied args to that Bid object and continue the flow
	// search for BidDoc where itemid=args[0] and bidder=args[2]
	bid, err := fetchBidForItemByBidder(APIstub,args[0], args[2])
	if err!=nil{
		// need to check if we need to catch this err
		logger.Info("Error when checking if bidder has already bided for item")
	}

	// if this a new bid only then assign the following
	if bid.BidId == ""{
		bid.ItemId = args[0]
		bid.Bidder = args[2]
		bid.Status = configObj.BidStatus.Active
		bid.BidId = bid.TypeOfObject + "-"+ APIstub.GetTxID()
	}
	
	// Add amount details for first Bid or Raise bid
	f,_ := strconv.ParseFloat(args[1], 32)
	bid.BidAmount = float32(f)
	
	
	// Check bidder is registered user
	exists,usrProfAsBytes := doesKeyExist(APIstub, bid.Bidder)
	if !exists{
		respBytes := formResponse(funcName(), "KeyNotFound", ":: Supplied Bidder("+bid.Bidder+") does not exist on stateDb")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	// Fetch user profile of Bidder
	var bidderProfile UserProfile
	errU1 := json.Unmarshal(usrProfAsBytes, &bidderProfile)
	if errU1 != nil{
		respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing Bidder User Profile object ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	} 

	roleValue, found, errC := cid.GetAttributeValue(APIstub,"role")
	if errC!=nil{
		logger.Info("Eror in cid.GetAttributeValue(\"role\") ")
	}

	logger.Info(roleValue, found)

	// Does bidder belong to Org2
	if roleValue != configObj.Role.Buyer{
		respBytes := formResponse(funcName(), "RoleNotAllowed", ":: User does not belong to "+configObj.Role.Buyer+" role ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)	
	}
	
	// Fetch Item details to know the current highest bid
	
	err, itemObjBytes := readFromLedger(APIstub, bid.ItemId)
	if err != nil {
		respBytes := formResponse(funcName(), "KeyNotFound", ":: Supplied ItemId("+bid.ItemId+") does not exist on stateDB ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}
	
	// Unmarshal the itembytes
	errU := json.Unmarshal(itemObjBytes, &item)
	if errU != nil{
		respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing Item object ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	
	// Verify that item can accept bids by checking the status
	timestamp,_ := APIstub.GetTxTimestamp() 
	Timestamp := time.Unix(timestamp.Seconds, 0) 
	logger.Info("Timestamp from GetTxTtimestamp::: ", Timestamp)

	unitTimeInRFC3339 := Timestamp.Format(time.RFC3339)
	
	placeBidTime, err1 := time.Parse(configObj.TxDateFormat, unitTimeInRFC3339)
	if err1!=nil{
		logger.Info("Eror in converting placeBidTime :: " + err1.Error())
	}
	auctionTime,err2 := time.Parse(configObj.DateFormat, item.AuctionEndTime)
	if err2 != nil{
		logger.Info("Eror in converting auctionTime :: " + err2.Error())
	}
	if placeBidTime.Truncate(24*time.Hour).After(auctionTime.Truncate(24*time.Hour)){
		respBytes := formResponse(funcName(), "ItemNotOnAuction", ":: Auction period for Item("+item.Name+") has reached end time ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	
	// Verify that BidAmount is greater than current highest bid	
	if item.CurrHighestBid > bid.BidAmount {
		bidAmt := fmt.Sprintf("%f", bid.BidAmount)
		currHighBid := fmt.Sprintf("%f", item.CurrHighestBid)

		respBytes := formResponse(funcName(), "AmountNotSatisfied", ":: Supplied BidAmount ("+bidAmt+") is less than current highest bid("+currHighBid+") ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	

	// Also, AvlBalance > total(bids placed by user) + current BidAmount

	bidList, errB := getBidsByBuyer(APIstub, bid.Bidder)
	if errB != nil{
		respBytes := formResponse(funcName(), "CouchDbQuery", ":: Error fetching item data from CouchDB ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	totalBidAmt := bid.BidAmount
	for _,singleBid := range bidList{
		if singleBid.Record.Status == configObj.BidStatus.Active{
			totalBidAmt += singleBid.Record.BidAmount
		}
	}
	
	
	if bidderProfile.AvlBalance < totalBidAmt{
		avlBal := fmt.Sprintf("%f", bidderProfile.AvlBalance)
		totBid := fmt.Sprintf("%f", totalBidAmt)
		respBytes := formResponse(funcName(), "AmountNotSatisfied", ":: Available balance is not sufficient to place bid (AvlBalance="+avlBal+"; Total Bid Amount="+totBid+")  ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	// if all conditions are satisfied commit changes to stateDB
	// Now commit Bid to stateDB
	if ok, errWriteBid := writeToLedger(APIstub, bid.BidId, bid); !ok {
		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Bid object to StateDB :: " + errWriteBid.Error() + "\"} "
		return shim.Error(jsonResp)	
	}
	
	// Update the current highest bid with supplied BidAmount
	item.CurrHighestBid = bid.BidAmount
	if ok, errWrite := writeToLedger(APIstub, item.ItemId, item); !ok {
		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while updating current highest bid to Item object on StateDB :: " + errWrite.Error() + "\"} "
		return shim.Error(jsonResp)	
	}

	// Marshal the object to send to event
	itemAsBytes, errI := json.Marshal(item)
	if errI!=nil{
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the item object - " + item.ItemId)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	// generate place-bid event
	err = APIstub.SetEvent(configObj.Event.PlaceBid, itemAsBytes)
	if err != nil {			
		respBytes := formResponse(funcName(), "InvalidEvent", ":: Error while setting "+ configObj.Event.PlaceBid+ " event")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}


	responseAsBytes, err1 := json.Marshal(bid)
	if err1!=nil{		
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the trade object")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}	

	// Success response would be the item that was created on Public State
	return shim.Success(responseAsBytes)
}

func fetchBidForItemByBidder(APIstub shim.ChaincodeStubInterface, itemId string, bidder string) (Bid, error){
	logger.Info("****** Entering  ", funcName(), " Args - ", itemId, bidder,  "***********")
	
	queryString   := fmt.Sprintf("{\"selector\":{\"typeOfObject\":\"%s\", \"bidder\":\"%s\", \"itemId\":\"%s\"} }", configObj.TypeOfObject.BidDoc, bidder, itemId)
	qryResultType := configObj.QryResultType.Multiple
	
	queryResults, err := getQueryResultForQueryString(APIstub, queryString, qryResultType)
	
	if err != nil {				
		var bid Bid
		bid.Init()
		return bid, err
	}
	logger.Info("Fetched results from public state")
	
	var bidList []BidList
	errU := json.Unmarshal(queryResults, &bidList)
	if errU != nil{
		var bid Bid
		bid.Init()
		return bid, errU
	}
	logger.Info("Bids fetch success")
	logger.Info(bidList)
	if len(bidList) == 0{
		var bid Bid
		bid.Init()
		return bid, nil
	}
	return bidList[0].Record, nil

}

/* getBidsByBuyer - fetch list of bids placed by a buyer
 - useful in calculating total bidAmount for active bids
*/
func getBidsByBuyer(APIstub shim.ChaincodeStubInterface, bidder string) ([]BidList, error){
	logger.Info("****** Entering  ", funcName(), " Args - ", bidder,  "***********")
	
	queryString   := fmt.Sprintf("{\"selector\":{\"typeOfObject\":\"%s\", \"bidder\":\"%s\"} }", configObj.TypeOfObject.BidDoc, bidder)
	qryResultType := configObj.QryResultType.Multiple
	
	queryResults, err := getQueryResultForQueryString(APIstub, queryString, qryResultType)
	
	if err != nil {				
		return []BidList{}, err
	}
	logger.Info("Fetched results from public state")
	
	var bidList []BidList
	errU := json.Unmarshal(queryResults, &bidList)
	if errU != nil{
		return []BidList{}, errU
	}
	logger.Info("Bids fetch success")
	logger.Info(bidList)
	return bidList, nil

}

/*

func (s *AuctionSC) listBidsByBuyer(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")
}
func (s *AuctionSC) listBidsByItem(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")
}
*/
func (s *AuctionSC) auction(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")

	// input parameter - itemId
	var item Item
	var itemPriv ItemPrivate

	configObj.Init()
	item.Init()
	itemPriv.Init()

	// Check input parameters - all mandatory parameters
	if len(args) != 1 {
		argslen := strconv.Itoa(len(args))
		logger.Info(args)

		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Incorrect #Args. Expecting 1 parameter - ItemId; Got " + argslen)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}
	
	// Add Public data to Item object
	itemId := args[0]

	// fetch teh item object using itemId
	err, itemObjBytes := readFromLedger(APIstub, itemId)
	if err != nil {
		respBytes := formResponse(funcName(), "KeyNotFound", ":: Supplied ItemId("+itemId+") does not exist on stateDB ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}

	logger.Info("fetch teh item object using itemId")
	// Unmarshal the itembytes
	errU := json.Unmarshal(itemObjBytes, &item)
	if errU != nil{
		respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing Item object ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	logger.Info("check whether itemId - auction end date has reached ")

	// check whether itemId - auction end date has reached 
	timestamp,_ := APIstub.GetTxTimestamp() 
	Timestamp := time.Unix(timestamp.Seconds, 0) 
	logger.Info("Timestamp from GetTxTtimestamp::: ", Timestamp)

	unitTimeInRFC3339 := Timestamp.Format(time.RFC3339)
	
	nowTime, err1 := time.Parse(configObj.TxDateFormat, unitTimeInRFC3339)
	if err1!=nil{
		logger.Error("Eror in converting nowTime :: " + err1.Error())
	}
	auctionTime,err2 := time.Parse(configObj.DateFormat, item.AuctionEndTime)
	if err2 != nil{
		logger.Error("Eror in converting auctionTime :: " + err2.Error())
	}
	if nowTime.Truncate(24*time.Hour).Before(auctionTime.Truncate(24*time.Hour)){
		respBytes := formResponse(funcName(), "AuctionTimeNotReached", ":: Auction period for Item("+item.Name+") has NOT reached end time ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	logger.Info("get all bids for item")
	// if yes then get all bids for item (verify if getQueryResultForQueryString gives data in sorted)
	
	bidList, errB := getBidsForItem(APIstub, itemId);
	if errB!=nil{
		respBytes := formResponse(funcName(), "CouchDBQuery", ":: Error in fetching data from couchDB ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	logger.Info(bidList)

	// if there are no bids then status-auctionCancelled
	if len(bidList) ==0{
		logger.Info("there are no bids then status-auctionCancelled")
		// TODO: auctionCancelled code of setting item status & generating event is repetitive; can be separated out in another function
		
		respBytes := cancelAuction(APIstub, &item, "Auction is canceled as there are no bids on item")
		return shim.Success(respBytes)
	}

	logger.Info("fetch reservePrice from private data")
	// fetch reservePrice from private data
	errP, privateDataBytes := readFromPrivateState(APIstub, configObj.ReservePriceCollName, item.ItemId)
	if errP!=nil{
		respBytes := formResponse(funcName(), "FetchFromLedger", ":: Error while fetching private data")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	var itemPrv ItemPrivate
	// Unmarshal the itembytes
	errU = json.Unmarshal(privateDataBytes, &itemPrv)
	if errU != nil{
		respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing ItemPrivate object ")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}
	
	fReservePrice, _ := strconv.ParseFloat(itemPrv.ReservePrice, 32)

	logger.Info("ReservePrice fetched")

	// if there are bids - find the highest bid amount
		
	// last record will have the lowest bidAmount
	totalBids := len(bidList)
	lowestBid := bidList[totalBids-1].Record.BidAmount

	logger.Info("lowest bid :: ", lowestBid)
	var bidderProfile UserProfile
	var bidObjwithHighestBA Bid
	foundEligibleBuyer := false

	for _, bidListObj := range bidList {

		// 0th element has the highest-BidAmount
		// Cancel the auction if highest bid amount is not satisfying reservePrice
		if bidListObj.Record.BidAmount < float32(fReservePrice){

			logger.Info("Cancel the auction if highest bid amount is not satisfying reservePrice")
			respBytes := cancelAuction(APIstub, &item, "Auction is canceled as bids do not satisfy the reserve-price")
			return shim.Success(respBytes)
		}
		
		logger.Info("highest bid amount is satisfying reservePrice")

		// Fetch user profile of bidder		
		err, userObjBytes := readFromLedger(APIstub, bidListObj.Record.Bidder)
		if err != nil {
			respBytes := formResponse(funcName(), "KeyNotFound", ":: Supplied bidder("+bidListObj.Record.Bidder+") does not exist on stateDB ")
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)				
		}
		
		// Unmarshal the itembytes
		errU := json.Unmarshal(userObjBytes, &bidderProfile)
		if errU != nil{
			respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing UserProfile object ")
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)
		}

		logger.Info("Bidder Profile :: ", bidderProfile)
		
		// if we find the eligible bidder who has avlBalance then the item needs to be sold
		if bidderProfile.AvlBalance > bidListObj.Record.BidAmount{
			logger.Info("foundEligibleBuyer")
			foundEligibleBuyer = true
			break;
		}else if bidListObj.Record.BidAmount == lowestBid{
			break;
		}

	}
	// cancel auction - none of the bidder has sufficient balance
	if !foundEligibleBuyer{
		logger.Info("cancel auction - none of the bidder has sufficient balance")		
		respBytes := cancelAuction(APIstub, &item, "Auction is canceled as none of the bidder has sufficient balance")
		return shim.Success(respBytes)	
	}else{
		// foundEligibleBuyer - item will be sold 
		// check whether the buyer has avlBalance > bid amount 
			// if yes then buyer.AvlBal -= bidAmt; item.owner = buyer; item.status = sold; seller.AvlBal += bidAmt
			// set event - item-sold
			
		logger.Info("foundEligibleBuyer - item will be sold")

		//fetch user profile of creator		
		exists,usrProfAsBytes := doesKeyExist(APIstub, item.Creator)
		if !exists{
			respBytes := formResponse(funcName(), "KeyNotFound", ":: Supplied creator("+item.Creator+") does not exist on stateDb")
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)
		}
		
		// Fetch user profile of seller`
		var creatorProfile UserProfile
		errU1 := json.Unmarshal(usrProfAsBytes, &creatorProfile)
		if errU1 != nil{
			respBytes := formResponse(funcName(), "UnmarshalErr", ":: Error while unmarshalling existing Seller User Profile object ")
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)
		} 
		item.Status = configObj.ItemStatus.Sold
		item.Owner = bidderProfile.LoginId
		
		bidderProfile.AvlBalance = bidderProfile.AvlBalance - bidObjwithHighestBA.BidAmount
		creatorProfile.AvlBalance = creatorProfile.AvlBalance + bidObjwithHighestBA.BidAmount
		
		logger.Info("Changed item object :: ", item)

		logger.Info("Changed balanbce - bidder :: ", bidderProfile)

		logger.Info("Changed creatorProfile", creatorProfile)

		// update all objects on stateDB		
		if ok, errWrite := writeToLedger(APIstub, item.ItemId, item); !ok {

			jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Item object to StateDB :: " + errWrite.Error() + "\"}"
			return shim.Error(jsonResp)	
		}
		
		if ok, errWrite := writeToLedger(APIstub, creatorProfile.LoginId, creatorProfile); !ok {

			jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Creator user profile object to StateDB :: " + errWrite.Error() + "\"}"
			return shim.Error(jsonResp)	
		}
		if ok, errWrite := writeToLedger(APIstub, bidderProfile.LoginId, bidderProfile); !ok {

			jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing Bidder profile object to StateDB :: " + errWrite.Error() + "\"}"
			return shim.Error(jsonResp)	
		}

		logger.Info("All 3 objects updated on stateDb")

		// Marshal the object to send to event
		itemAsBytes, errI := json.Marshal(item)
		if errI!=nil{
			respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the item object - " + item.ItemId)
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)
		}

		// generate  event
		err = APIstub.SetEvent(configObj.Event.AuctionSold, itemAsBytes)
		if err != nil {			
			respBytes := formResponse(funcName(), "InvalidEvent", ":: Error while setting "+ configObj.Event.AuctionSold+ " event")
			if respBytes == nil{
				return shim.Error("Error while marshalling the response object")
			}
			return shim.Success(respBytes)
		}

		logger.Info("AuctionSold Event generated")
		
		respBytes := formResponse(funcName(), "AuctionSold", ":: Item is sold to " + bidderProfile.LoginId)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)	
	}		
}

/* getBidsByBuyer - fetch list of bids placed by a buyer
 - useful in calculating total bidAmount for active bids
*/
func getBidsForItem(APIstub shim.ChaincodeStubInterface, itemId string) ([]BidList, error){
	logger.Info("****** Entering  ", funcName(), " Args - ", itemId,  "***********")
	
	queryString   := fmt.Sprintf("{\"selector\":{\"typeOfObject\":\"%s\", \"itemId\":\"%s\"} ,\"sort\":[{\"bidAmount\":\"desc\"}]}", configObj.TypeOfObject.BidDoc, itemId)
	qryResultType := configObj.QryResultType.Multiple
	
	queryResults, err := getQueryResultForQueryString(APIstub, queryString, qryResultType)
	
	if err != nil {				
		return []BidList{}, err
	}
	logger.Info("Fetched results from public state")
	
	var bidList []BidList
	errU := json.Unmarshal(queryResults, &bidList)
	if errU != nil{
		return []BidList{}, errU
	}
	logger.Info("Bids fetch success")
	logger.Info(bidList)
	return bidList, nil

}


func (s *AuctionSC) registerUser(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")

	var user UserProfile

	configObj.Init()
	user.Init()

	// Check input parameters - all mandatory parameters
	if len(args) != 4 {
		argslen := strconv.Itoa(len(args))
		logger.Info(args)

		respBytes := formResponse(funcName(), "IncorrectArgs", ":: Incorrect #Args. Expecting 4 parameters in given order - LoginId, AvlBalance, Currency, Role; Got " + argslen)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)				
	}

	user.LoginId = args[0]
	f, _ := strconv.ParseFloat(args[1], 32)
	user.AvlBalance = float32(f)
	user.Currency = args[2]
	user.Role = args[3]
	user.Remarks = "Initialize AvlBalance with " + args[1] + " for currency " + user.Currency

	// Check if supplied role is supported
	if !stringInSlice(user.Role, RoleSupported){		
		respBytes := formResponse(funcName(), "RoleNotSupported", user.Role + " is not a valid role")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	logger.Info("Writing public data to stateDB")
	
	if ok, errWrite := writeToLedger(APIstub, user.LoginId, user); !ok {

		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while writing UserProfile object to StateDB :: " + errWrite.Error() + "\"} "
		return shim.Error(jsonResp)	
	}

	logger.Info(funcName() + ":: Created UserProfile object on stateDB with Id - ", user.LoginId)

	// Marshal the object to send to event
	userAsBytes, err := json.Marshal(user)
	if err!=nil{
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the user object - " + user.LoginId)
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	// generate user-registered event
	err = APIstub.SetEvent(configObj.Event.UserRegistered, userAsBytes)
	if err != nil {			
		respBytes := formResponse(funcName(), "InvalidEvent", ":: Error while setting "+ configObj.Event.UserRegistered + " event")
		if respBytes == nil{
			return shim.Error("Error while marshalling the response object")
		}
		return shim.Success(respBytes)
	}

	// Success response would be the user object that was created on Public State
	return shim.Success(userAsBytes)
}
/*
func (s *AuctionSC) viewUser(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")
}
func (s *AuctionSC) addToAvlBalance(APIstub shim.ChaincodeStubInterface, args[]string) sc.Response{	
	logger.Info("****** Entering  ", funcName(), " Args - ", args,  "***********")
}
*/
/* cancelAuction - sets status to auction-cancelled; updates item object on stateDB and generates event
*/
func cancelAuction(APIstub shim.ChaincodeStubInterface, item *Item, reason string)([]byte){

	logger.Info("****** Entering  ", funcName(), " Args - ", item, reason,  "***********")

	item.Status = configObj.ItemStatus.AuctionCanceled
	
	if ok, errWrite := writeToLedger(APIstub, item.ItemId, item); !ok {
		jsonResp := "{\"errCode\":\"InvalidPutState\", \"errMessage\":\"Error while updating auction-canceled status to Item object on StateDB :: " + errWrite.Error() + "\"} "
		return []byte(jsonResp)	
	}

	// Marshal the object to send to event
	itemAsBytes, errI := json.Marshal(item)
	if errI!=nil{
		respBytes := formResponse(funcName(), "MarshallingErr", "Error while marshalling the item object - " + item.ItemId)
		return respBytes
	}

	// generate  event
	err := APIstub.SetEvent(configObj.Event.AuctionCanceled, itemAsBytes)
	if err != nil {			
		respBytes := formResponse(funcName(), "InvalidEvent", ":: Error while setting "+ configObj.Event.AuctionCanceled+ " event")
		return respBytes
	}

	logger.Info("auctionCancelled event generated")
	respBytes := formResponse(funcName(), "AuctionCanceled", ":: " + reason)
	return respBytes
}

/* formResponse sends out the function name where error was generated, errCode and errMessage 
*/
func formResponse(errOrigin string, errCode string, errMsg string)([]byte){
	var resp Response

	resp.ErrCode 	= errCode
	resp.ErrMessage = errMsg
	
	logger.Error(errOrigin, resp.ErrMessage)

	responseAsBytes, err1 := json.Marshal(resp)
	if err1!=nil{
		logger.Error("Error while marshalling the response object")
		return nil
	}	
	return responseAsBytes
}

func stringInSlice(a string, list []string) bool {
    for _, b := range list {
        if b == a {
            return true
        }
    }
    return false
}

/* funcName
 -  to get function name at runtime; used in every function for tracing and debugging
*/
func funcName() string{
	pc := make([]uintptr, 10)  // at least 1 entry needed
    runtime.Callers(2, pc)
    f := runtime.FuncForPC(pc[0])
    
	return f.Name()
}

/* entry point for smart contract */
func main(){
	
	err:= shim.Start(new (AuctionSC))
	if err!=nil{
		logger.Error("Error creating Auction Smart Contract")
	}
}